//
//  pointer.m
//  C
//
//  Created by 陈磊 on 2018/10/22.
//  Copyright © 2018 sinosoft. All rights reserved.
//



/*
 笔记：
     1.从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
     (1)int*ptr;//指针的类型是int*
     (2)char*ptr;//指针的类型是char*
     (3)int**ptr;//指针的类型是int**
     (4)int(*ptr)[3];//指针的类型是int(*)[3]
     (5)int*(*ptr)[4];//指针的类型是int*(*)[4]
 
     2.当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
 
     3.指针的类型(即指针本身的类型)和指针所指向的类型是两个概念
 
     4.指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。
 
     5.一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
 
     6.指针是一个地址，而指针变量是存放地址的变量。 所以说指针变量必定指向的是一个变量的地址，不是直接指向变量所指向的内容  但是为什么可以 NSString *s = @"a"
 
     7.“使指针向后移 1 个位置”或“使指针加 1”，这个 1 代表什么呢？这个 1 与指针变量的基类型是直接相关的。指针变量的基类型占几字节，这个 1 代表的就是几
 
     8.在实际编程中我们都是传递指针！往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：
     1)数据很小，比如就一个 int 型变量。
     2)不需要改变它的值，只是使用它的值。
 
     9.当形参作为参数在函数中的时候 此时对形参传实参的时候只是值传递 并没有办法改实参的内存地址的内容 如果需要修改实参的地址的内容需要传递的是指针
 
 
 
 
 疑问：
 
 */

#import "pointer.h"

@implementation pointer
-(instancetype)init
{
    if (self = [super init]) {
        
        [self pointertest];
        
    }
    return self;
}



-(void)pointertest
{
    
    
    
    char *a = "a";
    /*
     笔记：测试依次定义两个变量  那么两个变量的地址是相邻的？
     
     
     疑问：
     
     */
    
    int i = 1;
    
    int l = 3;
    
    int *j, *k;
    
    j = &i;
    
    k = &l ;
    
    char b = 'b';
    
    /*
     笔记：
     数组的参数名就是内存地址的指针 并不需要用*号 包括字符串
   
     疑问：
     
     */
    
    char c[2] = "b";
    
    /*
     笔记：
     
     d指针还未初始化，所以它所指向的内存区是不存在的
     
     
     疑问：1.char a = 'a' 可以 但是char *a = 'a'不行？
     
     */
    
    char *d = NULL;
    
    char e[2] = "e";
    
    /*
     笔记：
     
     
     
     
     疑问：
     
     */
    
    NSLog(@"%ld--%ld--%ld",l,*j,&l);
    
    NSLog(@"%s--%c--%s--%s--%s",a,b,c,d,e);
    
    int x = 10;
    
    int *y = NULL;
    
    /*
     笔记：
     不能往一个存放NULL地址的指针变量里面写入数据 但是可以写入地址
     
     
     
     
     疑问：
     
     */
    
    
    
    
    y = &x;
    
//    *y = 20;
    
    *y = 20;
    
    NSLog(@"%d**%d",x,*y);
    
    /*
     笔记：下面这种情况只是值传递 只是将i和l的值传递给了函数的形参 传递的只是值这样并不能将i和j的值按照参数的 方式变化
     
     疑问：
     
     */
    changeValue1(i, l);
    
    NSLog(@"%d--%d",i,l);
    
    /*
     笔记：这种情况下是将地址传递给了函数 那么就可以根据地址来修改这个地址下的值 这样就可以对i和j这两个变量进行修改了
     
     疑问：
     
     */
    
    changeValue(&i, &l);
    
    NSLog(@"%d--%d",i,l);
    
    
}



void changeValue(int *a , int *b){
    
    int c;
    
    c = *a;
    
    *a = *b;
    
    *b = c;
    
}

void changeValue1(int a , int b){
    
    int c;
    
    c = a;
    
    a = b;
    
    b = c;
    
}
-(void)constTest
{
    /*
     笔记：
    1.它是定义只读变量的关键字，或者说 const 是定义常变量的关键字。
    2.用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。
    3.用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程，使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程，用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。
    4.局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。
     
    5.const VS define：
     1）define是预编译指令，而const是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
     2）const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。
     3）const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。
     
     
     
     const  int  a = 10;和int  const  a = 10; 等价
     
     疑问：
     
     */
    
    
    
}
-(void)arrayTest
{
    
}
@end
