//
//  pointer.m
//  C
//
//  Created by 陈磊 on 2018/10/22.
//  Copyright © 2018 sinosoft. All rights reserved.
//



/*
 笔记：
     1.从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
     (1)int*ptr;//指针的类型是int*
     (2)char*ptr;//指针的类型是char*
     (3)int**ptr;//指针的类型是int**
     (4)int(*ptr)[3];//指针的类型是int(*)[3]
     (5)int*(*ptr)[4];//指针的类型是int*(*)[4]
 
     2.当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
 
     3.指针的类型(即指针本身的类型)和指针所指向的类型是两个概念
 
     4.指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。
 
     5.一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
 
     6.指针是一个地址，而指针变量是存放地址的变量。 所以说指针变量必定指向的是一个变量的地址，不是直接指向变量所指向的内容  但是为什么可以 NSString *s = @"a"
 
     7.“使指针向后移 1 个位置”或“使指针加 1”，这个 1 代表什么呢？这个 1 与指针变量的基类型是直接相关的。指针变量的基类型占几字节，这个 1 代表的就是几
 
     8.在实际编程中我们都是传递指针！往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：
     1)数据很小，比如就一个 int 型变量。
     2)不需要改变它的值，只是使用它的值。
 
     9.当形参作为参数在函数中的时候 此时对形参传实参的时候只是值传递 并没有办法改实参的内存地址的内容 如果需要修改实参的地址的内容需要传递的是指针
 
 
 
 
 疑问：
 
 */

#import "pointer.h"

@implementation pointer
-(instancetype)init
{
    if (self = [super init]) {
        
        [self constTest];
        
    }
    return self;
}



-(void)pointertest
{
    
    
    
    char *a = "a";
    /*
     笔记：测试依次定义两个变量  那么两个变量的地址是相邻的？
     
     
     疑问：
     
     */
    
    int i = 1;
    
    int l = 3;
    
    int *j, *k;
    
    j = &i;
    
    k = &l ;
    
    char b = 'b';
    
    /*
     笔记：
     数组的参数名就是内存地址的指针 并不需要用*号 包括字符串
   
     疑问：
     
     */
    
    char c[2] = "b";
    
    /*
     笔记：
     
     d指针还未初始化，所以它所指向的内存区是不存在的
     
     
     疑问：1.char a = 'a' 可以 但是char *a = 'a'不行？
     
     */
    
    char *d = NULL;
    
    char e[2] = "e";
    
    /*
     笔记：
     
     
     
     
     疑问：
     
     */
    
    NSLog(@"%ld--%ld--%ld",l,*j,&l);
    
    NSLog(@"%s--%c--%s--%s--%s",a,b,c,d,e);
    
    int x = 10;
    
    int *y = NULL;
    
    /*
     笔记：
     不能往一个存放NULL地址的指针变量里面写入数据 但是可以写入地址
     
     
     
     
     疑问：
     
     */
    
    
    
    
    y = &x;
    
//    *y = 20;
    
    *y = 20;
    
    NSLog(@"%d**%d",x,*y);
    
    /*
     笔记：下面这种情况只是值传递 只是将i和l的值传递给了函数的形参 传递的只是值这样并不能将i和j的值按照参数的 方式变化
     
     疑问：
     
     */
    changeValue1(i, l);
    
    NSLog(@"%d--%d",i,l);
    
    /*
     笔记：这种情况下是将地址传递给了函数 那么就可以根据地址来修改这个地址下的值 这样就可以对i和j这两个变量进行修改了
     
     疑问：
     
     */
    
    changeValue(&i, &l);
    
    NSLog(@"%d--%d",i,l);
    
    
}



void changeValue(int *a , int *b){
    
    int c;
    
    c = *a;
    
    *a = *b;
    
    *b = c;
    
}

void changeValue1(int a , int b){
    
    int c;
    
    c = a;
    
    a = b;
    
    b = c;
    
}
-(void)constTest
{
    /*
     笔记：
    1.它是定义只读变量的关键字，或者说 const 是定义常变量的关键字。
    2.用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。
    3.用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程，使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程，用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。
    4.局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。
     
    5.const VS define：
     1）define是预编译指令，而const是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
     2）const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。
     3）const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。
     
     const  int  a = 10;和int  const  a = 10; 等价
     
     6.用const修饰变量的时候修饰的是哪个变量，就说明通过这个变量去修改变量所对应的存储空间是不能进行修改的，但是并不是说明这个存储空间就是不能修改了，通过其他的变量或者指针还是可以对这个空间进行修改的 这点一定要清楚
     
     疑问：
     
     */
    
    
    int i1 = 10;
    int i2 = 20;
    /*
     笔记：这里const修饰的*p 也就是说修饰的i1这个值
     
     疑问：
     
     */
    const int *p = &i1;
    /* 输出结果是10 */
    printf("%d\n", *p);
    p = &i2;
    /* 输出结果是20 */
    printf("%d\n", *p);
    i2 = 30;
    /* 输出结果是30 */
    printf("%d\n", *p);
    
    int *const q = &i1;
    
    printf("%d\n",*q);
    /* q = &i2;这样写会报错 */
    
    
    const int i=10;
    int *a;
    /* 强制类型转换  因此下面的语句是不合法的:p = &i; 但是可以进行强制转换来修改地址*/
    a= (int *) &i;
    
    
}
-(void)arrayTest
{
    /*
     笔记：
     1.即第一个元素的第一字节的地址。我们将“数组第一个元素的起始地址”称为“数组的首地址”。数组名表示的就是数组的首地址，即数组第一个元素的第一字节的地址
     2.数组名不代表整个数组，q=a 表示的是“把数组 a 的第一个元素的起始地址赋给指针变量 q”，而不是“把数组 a 的各个元素的地址赋给指针变量 q”。
     3.如果指针变量 p 已经指向一维数组的第一个元素，那么 p+1 就表示指向该数组的第二个元素。
     4.*q+i 和 *(q+i)是不等价的。指针运算符“*”的优先级比加法运算符“+”的优先级高。所以 *q+i 就相当于 (*q)+i 了。
     
     疑问：
     
     */
    int a[] = {1,2,37,4,5};
    int *p = &a[0];
    int *q = a;
    printf("*p=%d,*q=%d,*(p+2)=%d,*p+2 = %d\n",*p,*q,*(p+2),*p+2);
    
    /*
     笔记：如下面的代码因为a作为数组的变量同样也表示a是第一个元素的地址指针，那么现在p和q的值和指针a的值是一样的那么 可以用a[1]表示第二个元素的值，同样也可以用p[2]或者q[2]表示
     
     疑问：在这里&a和a的输出值是一样的 表明a是一个存储地址的常量
     
     */
    
    printf("p[1]=%d,q[1]=%d,a[1]=%d,a=%ld，&a = %ld,p=%ld,&p = %ld,q=%ld\n",p[1],q[1],a[1],a,&a,p,&p,q);
    
    /*
     笔记：
     1.因为指针运算符“*”和自增运算符“++”的优先级相同，而它们的结合方向是从右往左，所以 *p++ 就相当于 *(p++)，*++p 就相当于 *(++p)。但是为了提高程序的可读性，最好加上括号。
     2.自增和自减的时候强调过，只有变量才能进行自增和自减，常量是不能进行自增和自减的。a 代表的是数组的首地址，是一个常量，所以不能进行自增，所以不能写成a++
     
     疑问：
     
     */
    
    int *m = NULL;  //先初始化, 好习惯
    for (m=a; m<(a+5); ++m)
    {
        printf("%d\n", *m);
    }
}
-(void)memoryTest
{
    /*
     笔记：
     1.动态内存是指在堆上分配的内存，而静态内存是指在栈上分配的内存。
     2.局部变量、形参、函数调用等基本上是在栈上分配的
     3.栈上分配的内存是由系统分配和释放的，空间有限，在复合语句或函数运行结束后就会被系统自动释放。而堆上分配的内存是由程序员通过编程自己手动分配和释放的，空间很大，存储自由。
     4.C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）
     5.动态分配的内存空间都有一个标志，即都是用一个系统的动态分配函数实现的如calloc和malloc
     6.下面这句代码的意思是：请求系统分配 4 字节的内存空间，并返回第一字节的地址，然后赋给指针变量 p。当用 malloc 分配动态内存之后，上面这个指针变量 p 就被初始化了。
     7.malloc 和 free 一定要成对存在，一一对应，只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放
     
     疑问：
     
     */
    
    int *a = (int *)malloc(4);
    
    /*
     笔记：free 函数无返回值，它的功能是释放指针变量所指向的内存单元 如将p指针所指向内存空间释放，但是此时的释放 并不是指清空p所指向的空间内存 而是指将这块空间标记为可用状态，一遍系统在分配内存的时候可以将这块内存分配给其他指针，但是其实就算是这个p和他原先指向的那块内存之间已经被没关系了  但是P的指向其实还是指向原来那块空间,如下面这段代码的结果  其实还是可以通过P这个指针对原指向空间进行复制 ，但是这时候要考虑到如果这块空间已经被系统分配到其他的指针了，那么再通过这个p对他进行修改的话，就会造成正常的其他的程序有错误的输出变量，这就不是我们想要看到的了 ，一般也就是我们所说的野指针错误，所以一般情况下我们需要进行这种操作的时候都需要对这个指针进行置null操作
     
     疑问：
     
     */
    
    int  *p = malloc(sizeof*p);
    
    NSLog(@"%ld",p);
    
    free(p);
    
    p = NULL;
    
    NSLog(@"%ld",p);
    
    
    
    
}
-(void)morePointer
{
    
    /*
     笔记：
     1.指针变量 p 的基类型为 int 型，所以 &p 的基类型为 int*型 。所以如果要定义一个能指向 int* 型变量的指针变量，有两个要求：首先它要是指针变量，即一个“*”；其次，该指针变量指向的是 int* 型的数据，或者说存放的是 int* 型变量的地址，所以就是 int**。
     2.动态内存分配之前经常有一句话，叫作“永远不要返回局部变量的地址”
     
     疑问：
     
     */
    int i = 10;
    int *p = &i;
    int **q = &p;
    int ***r = &q;
    NSLog(@"*p=%d,**q=%d,***r=%d",*p,**q,***r);
    
    
    int j = 2;
    int *e = &j;
    DynamicArray(e);  //函数调用
    printf("*p = %d\n", *e);
    
    int *d = NULL;
    DynamicArray1(&d);
    printf("*p = %d\n", *d);
    
    
}
void DynamicArray(int *q)
{
    q = malloc(sizeof*q);
    *q = 5;
    return;
}
void DynamicArray1(int **q)
{
    //如果此时传入的实参并没有被初始化的话 那么必须写上上面这句话 因为如果没有这句话的话就表示*q这个变量是没有初始化的是不存在的会报错的
    
    *q = malloc(sizeof*q);
    
    **q = 5;
    
    return;
    
}

-(void)dyadicArray
{
    
    /*
     笔记：
     1.a[0]、a[1]、a[2] 既然是一维数组名，一维数组的数组名表示的就是数组第一个元素的地址，所以 a[0] 表示的就是元素 a[0][0] 的地址，即 a[0]==&a[0][0]；a[1] 表示的就是元素 a[1][0] 的地址，即 a[1]==&a[1][0]；a[2] 表示的就是元素 a[2][0] 的地址，即 a[2]==&a[2][0]。
     2.即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。
     
     疑问：如果我输出*a[3] 并不会报错 但是会输出0？ 这证明在c语言数组中并不会出现数组越界的情况 ？
     
     */
    int a[3][4] = {{1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23}};
    
    int b[3] = {1, 3, 5, 7};
    
    printf("%d--%d--%d\n",*a[5],**a,*b);
    
    /*
     笔记：如果按照下面的方式输入为：140732753012876--140732753012880,140732753012896 此时a[2][3]和a[3]的地址差距为4 为int长度，但是a[4]的地址却比a[3]多16个长度 是4个int的长度和二维数组的第二维度长度吻合
     
     疑问：
     
     */
    
    
    printf("%ld--%ld,%ld\n",&a[2][3],&a[3],&a[4]);
    /*
     笔记：
     
     疑问：
     
     */
    
    printf("%d--%d--%d\n",*(a[0]+2),a[0][2],*(&a[0][1]+1));
    
    /*
     笔记：
     1.二维数组就是一维数组，二维数组 a[3][4] 就是有三个元素 a[0]、a[1]、a[2] 的一维数组，所以数组 a 的第一个元素不是 a[0][0]，而是 a[0]，所以数组名 a 表示的不是元素 a[0][0] 的地址，而是 a[0] 的地址，即：
     a == &a[0]
     而 a[0] 又是 a[0][0] 的地址，即：
     a[0] == &a[0][0]
     所以二维数组名 a 和元素 a[0][0] 的关系是：
     a == &(&a[0][0])
     即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。
     
     2.如第一条所示如果想让p指针指向a这个二维数组的话 那么就必须将*a赋值给p 因为此时a的类型是 int *[3][4] 类型并不是int*类型 并不能直接将a直接赋值给p，因为两者的类型并不一致,那么哪个的类型是int *呢，肯定是a[0][0]， 而a == &a[0] 而a[0] = &[0][0]那么 a=&&a[0][0] &a[0][0]类型为int *类型所以需要把*a的值赋值给p
     3.这种赋值方式虽然不能用p[2][1]这种方式但是 因为在内存中存储的时候并没有什么一位数组二维数组存储方式都是线性存储的所以我们完全可以用*(p+2*4+1)
     疑问：
     
     */
    
    int *p = NULL;
    
    p = *a;
    
    printf("%d--%d--%d\n",*p,*(p+1),*(p+2*4+1));
    
    /*
     笔记：如下方这样定义可以直接将a赋值给q然后写法可以完全按照a的写法来取值
     
     疑问：
     
     */
    
    int (*q)[4] = NULL;
    
    q = a;
    
    printf("%ld--%d\n",a,*q[0]);
    
    
    /*
     笔记：
     1.“int*p1[5]”，因为“[]”的优先级要比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“int*”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，
     2.“int(*p2)[5]”，“()”的优先级比“[]”高，“*”号和 p2 构成一个指针的定义，指针变量名为 p2，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组，
     
     疑问：
     
     */
    
    int arr[5]={1,2,3,4,5};
    int (*p1)[5] = &arr;
    /*下面是错误的*/
    /*
     笔记：&arr 是指整个数组的首地址，而 arr 是指数组首元素的首地址，虽然所表示的意义不同，但二者之间的值却是相同的。
     在 C 语言中，赋值符号“=”号两边的数据类型必须是相同的，如果不同，则需要显示或隐式类型转换。 因为此时 p2的类型是 int类型的数组 但是arr是数组的首地址也就是第一个元素的地址，但是第一个元素的地址是int类型两者的类型并不是相同的，所以此时无法进行相等的操作，如果确实需要这样写的话 可以进行类型的强制转换
     
     疑问：
     
     */
    int (*p2)[5] = arr;

    
}

/*
 笔记：
 1.如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。
 2.所以函数指针的定义方式为：函数返回值类型 (* 指针变量名) (函数参数列表);
 3.需要注意的是：“（*指针变量名）”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数。
 4.最后需要注意的是，指向函数的指针变量没有 ++ 和 -- 运算。
 5.int Func(int x);   声明一个函数
   int (*p) (int x);  定义一个函数指针
   p = Func;          将Func函数的首地址赋给指针变量p
 
 
 疑问：
 
 */
-(void)functionPointer
{
    void (*changeFun)(int *,int *);
    changeFun = changeValue;
    int a = 0;
    int b = 1;
    (*changeFun)(&a,&b);
    printf("%d,%d\n",a,b);
    
}
-(void)pointer
{
    /*
     笔记：
     1.指针（pointer）是对数据对象或函数的一种引用。指针有多种用途，例如定义“传址调用”函数，它还可以实现动态数据结构，例如链表和树。
     2.通常，管理大量数据的有效方法不是直接处理数据本身，而是使用指向数据的指针。比如，如果要对大量的数据进行排序的话最好的方式是对这些数据的指针进行拍讯，儿并不是对这些数据本身进行排序，因为如果是这样的话就会造成大量的数据在内存中移动来移动去的
     3.C 也允仵使用指针类型来定义变量：类型 * [类型限定符列表] 名称 [= 初始化器];在声明中，星号（*）表示“指向的指针”。标识符“名称”被声明为一个对象，其对象类型为“类型”，也就是“指向‘类型’的指针”。类型限定符为可选择项，可能包含 const、volatile 和 restrict 的任意组合。
     4.无论指针所指对象的类型是什么，在内存中指针空间的大小（例如，表达式 sizeof（iPtr））都是一样的
     5.值为 0 的整型常量表达式，或强制（转换）为“void*”类型的此类表达式，称为空指针常量。当将一个空指针常量赋予一个指针或与指针作比较时，将把该常量转换为指向该类型的指针，这样的指针称为空指针。空指针在与指向任何对象或函数的指针作比较时保证不会相等。
     6.每一种指针类型都有一个空指针，它与同类型的其他所有指针值都不相同。
     7.由系统保证空指针不指向任何实际的对象或函数，也就是说，任何对象或者函数的地址都不可能是空指针，空指针与任何对象或函数的指针值都不相等。因此，取地址操作符 & 永远也不能得到空指针，同样对 malloc() 函数的成功调用也不会返回空指针，但如果调用失败，则 malloc() 函数返回空指针。
     8.空指针表示“未分配”或者“尚未指向任何地方”。它与未初始化的指针有所不同，空指针可以确保不指向任何对象或函数，而未初始化指针可能指向任何地方。
     9.0、0L、'\0'、3-3、0*17以及(void*)0等都是空指针常量
     10.对于空指针究竟指向内存的什么地方，在标准中并没有明确规定。也就是说，用哪个具体的地址值（0 地址还是某一特定地址）来表示空指针完全取决于系统的实现，在一般情况下，空指针指向 0 地址，即空指针的内部用全 0 来表示，也可以称它为零空指针。当然，也有一些系统用一些特殊的地址值或特殊的方式来表示空指针，也可以称它为非零空指针。
     
     11.为了让程序中的空指针使用更加明确，从而保持统一的编程风格，标准 C 专门定义了一个标准预处理宏 NULL，其值为“空指针常量”，通常是 0 或者“((void*)0)”，即在指针上下文中的 NULL 与 0 是等价的，而未加修饰的 0 也是完全可以接受的。
     12.当 NULL 定义为“((void *)0)”时，即 NULL 是可以赋值给任何类型指针的值，它的类型为 void*，而不是整数 0，因此初始化“FILE*fp=NULL;”是完全合法的。
     13.常数 0 是一个空指针常量，而 NULL 仅仅是它的一个别名。NULL 可以确保是 0，但空（null）指针却不一定。
     
     疑问：
     
     */
    
    int *p;
    p=0;
    /*或者* 此处0l表示长整型的0/
    p=0l;
    /*或者*，数组结束符/
    p='\0';
    /*或者*/
    p=3-3;
    /*或者*/
    p=0*17;
    /*或者*/
    p=(void*)0;
    /*
     笔记：指针变量 p 经过上面任何一种赋值操作之后都将成为一个空指针。至于编译时系统究竟选取哪种形式作为空指针常量使用，则与具体实现相关
     
     疑问：
     
     */
    
    /*
     笔记：
     1.void*指针表示的是无类型指针，正是由于它并没有特定的类型，所以可以用他来指向任何类型的数据，也就是说可以将任何指针类型的指针赋值给void*类型的指针，但是翻过来却不行，所以如果要将void*指针类型赋值给其他类型的指针必须进行指针类型的强制转换才能行
     2.进行算法操作的指针必须确定知道其指向数据类型大小，也就是说必须知道内存目的地址的确切值，所以说不通类型的指针做强转换之后在运算在一定程度上也是有危险的，并且不能对void*进行运算，因为在内存中我们根本不知道这个指针指向的空间具体是如何去读取的那么我们根本没有办法对这个空间的值进行精准的操作
     
     
     疑问：
     
     */
    
}
@end
