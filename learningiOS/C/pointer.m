//
//  pointer.m
//  C
//
//  Created by 陈磊 on 2018/10/22.
//  Copyright © 2018 sinosoft. All rights reserved.
//



/*
 笔记：
     1.从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
     (1)int*ptr;//指针的类型是int*
     (2)char*ptr;//指针的类型是char*
     (3)int**ptr;//指针的类型是int**
     (4)int(*ptr)[3];//指针的类型是int(*)[3]
     (5)int*(*ptr)[4];//指针的类型是int*(*)[4]
 
     2.当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
 
     3.指针的类型(即指针本身的类型)和指针所指向的类型是两个概念
 
     4.指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。
 
     5.一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
 
     6.指针是一个地址，而指针变量是存放地址的变量。 所以说指针变量必定指向的是一个变量的地址，不是直接指向变量所指向的内容  但是为什么可以 NSString *s = @"a"
 
     7.“使指针向后移 1 个位置”或“使指针加 1”，这个 1 代表什么呢？这个 1 与指针变量的基类型是直接相关的。指针变量的基类型占几字节，这个 1 代表的就是几
 
     8.在实际编程中我们都是传递指针！往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：
     1)数据很小，比如就一个 int 型变量。
     2)不需要改变它的值，只是使用它的值。
 
     9.当形参作为参数在函数中的时候 此时对形参传实参的时候只是值传递 并没有办法改实参的内存地址的内容 如果需要修改实参的地址的内容需要传递的是指针
 
 
 
 
 疑问：
 
 */

#import "pointer.h"

@implementation pointer
-(instancetype)init
{
    if (self = [super init]) {
        
        [self pointertest];
        
    }
    return self;
}



-(void)pointertest
{
    
    
    
    char *a = "a";
    /*
     笔记：测试依次定义两个变量  那么两个变量的地址是相邻的？
     
     
     疑问：
     
     */
    
    int i = 1;
    
    int l = 3;
    
    int *j, *k;
    
    j = &i;
    
    k = &l ;
    
    char b = 'b';
    
    /*
     笔记：
     数组的参数名就是内存地址的指针 并不需要用*号 包括字符串
   
     疑问：
     
     */
    
    char c[2] = "b";
    
    /*
     笔记：
     
     d指针还未初始化，所以它所指向的内存区是不存在的
     
     
     疑问：1.char a = 'a' 可以 但是char *a = 'a'不行？
     
     */
    
    char *d = NULL;
    
    char e[2] = "e";
    
    /*
     笔记：
     
     
     
     
     疑问：
     
     */
    
    NSLog(@"%ld--%ld--%ld",l,*j,&l);
    
    NSLog(@"%s--%c--%s--%s--%s",a,b,c,d,e);
    
    int x = 10;
    
    int *y = NULL;
    
    /*
     笔记：
     不能往一个存放NULL地址的指针变量里面写入数据 但是可以写入地址
     
     
     
     
     疑问：
     
     */
    
    
    
    
    y = &x;
    
//    *y = 20;
    
    *y = 20;
    
    NSLog(@"%d**%d",x,*y);
    
    /*
     笔记：下面这种情况只是值传递 只是将i和l的值传递给了函数的形参 传递的只是值这样并不能将i和j的值按照参数的 方式变化
     
     疑问：
     
     */
    changeValue1(i, l);
    
    NSLog(@"%d--%d",i,l);
    
    /*
     笔记：这种情况下是将地址传递给了函数 那么就可以根据地址来修改这个地址下的值 这样就可以对i和j这两个变量进行修改了
     
     疑问：
     
     */
    
    changeValue(&i, &l);
    
    NSLog(@"%d--%d",i,l);
    
    
}



void changeValue(int *a , int *b){
    
    int c;
    
    c = *a;
    
    *a = *b;
    
    *b = c;
    
}

void changeValue1(int a , int b){
    
    int c;
    
    c = a;
    
    a = b;
    
    b = c;
    
}
@end
