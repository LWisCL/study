//
//  pointer.m
//  C
//
//  Created by 陈磊 on 2018/10/22.
//  Copyright © 2018 sinosoft. All rights reserved.
//



/*
 笔记：
     1.从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
     (1)int*ptr;//指针的类型是int*
     (2)char*ptr;//指针的类型是char*
     (3)int**ptr;//指针的类型是int**
     (4)int(*ptr)[3];//指针的类型是int(*)[3]
     (5)int*(*ptr)[4];//指针的类型是int*(*)[4]
 
     2.当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
 
     3.指针的类型(即指针本身的类型)和指针所指向的类型是两个概念
 
     4.指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。
 
     5.一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
 
     6.指针是一个地址，而指针变量是存放地址的变量。 所以说指针变量必定指向的是一个变量的地址，不是直接指向变量所指向的内容  但是为什么可以 NSString *s = @"a"
 
     7.“使指针向后移 1 个位置”或“使指针加 1”，这个 1 代表什么呢？这个 1 与指针变量的基类型是直接相关的。指针变量的基类型占几字节，这个 1 代表的就是几
 
     8.在实际编程中我们都是传递指针！往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：
     1)数据很小，比如就一个 int 型变量。
     2)不需要改变它的值，只是使用它的值。
 
     9.当形参作为参数在函数中的时候 此时对形参传实参的时候只是值传递 并没有办法改实参的内存地址的内容 如果需要修改实参的地址的内容需要传递的是指针
 
 
 
 
 疑问：
 
 */

#import "pointer.h"

@implementation pointer
-(instancetype)init
{
    if (self = [super init]) {
        
        [self constTest];
        
    }
    return self;
}



-(void)pointertest
{
    
    
    
    char *a = "a";
    /*
     笔记：测试依次定义两个变量  那么两个变量的地址是相邻的？
     
     
     疑问：
     
     */
    
    int i = 1;
    
    int l = 3;
    
    int *j, *k;
    
    j = &i;
    
    k = &l ;
    
    char b = 'b';
    
    /*
     笔记：
     数组的参数名就是内存地址的指针 并不需要用*号 包括字符串
   
     疑问：
     
     */
    
    char c[2] = "b";
    
    /*
     笔记：
     
     d指针还未初始化，所以它所指向的内存区是不存在的
     
     
     疑问：1.char a = 'a' 可以 但是char *a = 'a'不行？
     
     */
    
    char *d = NULL;
    
    char e[2] = "e";
    
    /*
     笔记：
     
     
     
     
     疑问：
     
     */
    
    NSLog(@"%ld--%ld--%ld",l,*j,&l);
    
    NSLog(@"%s--%c--%s--%s--%s",a,b,c,d,e);
    
    int x = 10;
    
    int *y = NULL;
    
    /*
     笔记：
     不能往一个存放NULL地址的指针变量里面写入数据 但是可以写入地址
     
     
     
     
     疑问：
     
     */
    
    
    
    
    y = &x;
    
//    *y = 20;
    
    *y = 20;
    
    NSLog(@"%d**%d",x,*y);
    
    /*
     笔记：下面这种情况只是值传递 只是将i和l的值传递给了函数的形参 传递的只是值这样并不能将i和j的值按照参数的 方式变化
     
     疑问：
     
     */
    changeValue1(i, l);
    
    NSLog(@"%d--%d",i,l);
    
    /*
     笔记：这种情况下是将地址传递给了函数 那么就可以根据地址来修改这个地址下的值 这样就可以对i和j这两个变量进行修改了
     
     疑问：
     
     */
    
    changeValue(&i, &l);
    
    NSLog(@"%d--%d",i,l);
    
    
}



void changeValue(int *a , int *b){
    
    int c;
    
    c = *a;
    
    *a = *b;
    
    *b = c;
    
}

void changeValue1(int a , int b){
    
    int c;
    
    c = a;
    
    a = b;
    
    b = c;
    
}
-(void)constTest
{
    /*
     笔记：
    1.它是定义只读变量的关键字，或者说 const 是定义常变量的关键字。
    2.用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。
    3.用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程，使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程，用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。
    4.局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。
     
    5.const VS define：
     1）define是预编译指令，而const是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
     2）const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。
     3）const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。
     
     const  int  a = 10;和int  const  a = 10; 等价
     
     6.用const修饰变量的时候修饰的是哪个变量，就说明通过这个变量去修改变量所对应的存储空间是不能进行修改的，但是并不是说明这个存储空间就是不能修改了，通过其他的变量或者指针还是可以对这个空间进行修改的 这点一定要清楚
     
     疑问：
     
     */
    
    
    int i1 = 10;
    int i2 = 20;
    /*
     笔记：这里const修饰的*p 也就是说修饰的i1这个值
     
     疑问：
     
     */
    const int *p = &i1;
    /* 输出结果是10 */
    printf("%d\n", *p);
    p = &i2;
    /* 输出结果是20 */
    printf("%d\n", *p);
    i2 = 30;
    /* 输出结果是30 */
    printf("%d\n", *p);
    
    int *const q = &i1;
    
    printf("%d\n",*q);
    /* q = &i2;这样写会报错 */
    
    
    const int i=10;
    int *a;
    /* 强制类型转换  因此下面的语句是不合法的:p = &i; 但是可以进行强制转换来修改地址*/
    a= (int *) &i;
    
    
}
-(void)arrayTest
{
    /*
     笔记：
     1.即第一个元素的第一字节的地址。我们将“数组第一个元素的起始地址”称为“数组的首地址”。数组名表示的就是数组的首地址，即数组第一个元素的第一字节的地址
     2.数组名不代表整个数组，q=a 表示的是“把数组 a 的第一个元素的起始地址赋给指针变量 q”，而不是“把数组 a 的各个元素的地址赋给指针变量 q”。
     3.如果指针变量 p 已经指向一维数组的第一个元素，那么 p+1 就表示指向该数组的第二个元素。
     4.*q+i 和 *(q+i)是不等价的。指针运算符“*”的优先级比加法运算符“+”的优先级高。所以 *q+i 就相当于 (*q)+i 了。
     
     疑问：
     
     */
    int a[] = {1,2,37,4,5};
    int *p = &a[0];
    int *q = a;
    printf("*p=%d,*q=%d,*(p+2)=%d,*p+2 = %d\n",*p,*q,*(p+2),*p+2);
    
    /*
     笔记：如下面的代码因为a作为数组的变量同样也表示a是第一个元素的地址指针，那么现在p和q的值和指针a的值是一样的那么 可以用a[1]表示第二个元素的值，同样也可以用p[2]或者q[2]表示
     
     疑问：在这里&a和a的输出值是一样的 表明a是一个存储地址的常量
     
     */
    
    printf("p[1]=%d,q[1]=%d,a[1]=%d,a=%ld，&a = %ld,p=%ld,&p = %ld,q=%ld\n",p[1],q[1],a[1],a,&a,p,&p,q);
    
    /*
     笔记：
     1.因为指针运算符“*”和自增运算符“++”的优先级相同，而它们的结合方向是从右往左，所以 *p++ 就相当于 *(p++)，*++p 就相当于 *(++p)。但是为了提高程序的可读性，最好加上括号。
     2.自增和自减的时候强调过，只有变量才能进行自增和自减，常量是不能进行自增和自减的。a 代表的是数组的首地址，是一个常量，所以不能进行自增，所以不能写成a++
     
     疑问：
     
     */
    
    int *m = NULL;  //先初始化, 好习惯
    for (m=a; m<(a+5); ++m)
    {
        printf("%d\n", *m);
    }
}
-(void)memoryTest
{
    /*
     笔记：
     1.动态内存是指在堆上分配的内存，而静态内存是指在栈上分配的内存。
     2.局部变量、形参、函数调用等基本上是在栈上分配的
     3.栈上分配的内存是由系统分配和释放的，空间有限，在复合语句或函数运行结束后就会被系统自动释放。而堆上分配的内存是由程序员通过编程自己手动分配和释放的，空间很大，存储自由。
     4.C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）
     5.动态分配的内存空间都有一个标志，即都是用一个系统的动态分配函数实现的如calloc和malloc
     6.下面这句代码的意思是：请求系统分配 4 字节的内存空间，并返回第一字节的地址，然后赋给指针变量 p。当用 malloc 分配动态内存之后，上面这个指针变量 p 就被初始化了。
     7.malloc 和 free 一定要成对存在，一一对应，只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放
     
     疑问：
     
     */
    
    int *a = (int *)malloc(4);
    
    /*
     笔记：free 函数无返回值，它的功能是释放指针变量所指向的内存单元 如将p指针所指向内存空间释放，但是此时的释放 并不是指清空p所指向的空间内存 而是指将这块空间标记为可用状态，一遍系统在分配内存的时候可以将这块内存分配给其他指针，但是其实就算是这个p和他原先指向的那块内存之间已经被没关系了  但是P的指向其实还是指向原来那块空间,如下面这段代码的结果  其实还是可以通过P这个指针对原指向空间进行复制 ，但是这时候要考虑到如果这块空间已经被系统分配到其他的指针了，那么再通过这个p对他进行修改的话，就会造成正常的其他的程序有错误的输出变量，这就不是我们想要看到的了 ，一般也就是我们所说的野指针错误，所以一般情况下我们需要进行这种操作的时候都需要对这个指针进行置null操作
     
     疑问：
     
     */
    
    int  *p = malloc(sizeof*p);
    
    NSLog(@"%ld",p);
    
    free(p);
    
    p = NULL;
    
    NSLog(@"%ld",p);
    
    
    
    
}
-(void)morePointer
{
    
    /*
     笔记：
     1.指针变量 p 的基类型为 int 型，所以 &p 的基类型为 int*型 。所以如果要定义一个能指向 int* 型变量的指针变量，有两个要求：首先它要是指针变量，即一个“*”；其次，该指针变量指向的是 int* 型的数据，或者说存放的是 int* 型变量的地址，所以就是 int**。
     2.动态内存分配之前经常有一句话，叫作“永远不要返回局部变量的地址”
     
     疑问：
     
     */
    int i = 10;
    int *p = &i;
    int **q = &p;
    int ***r = &q;
    NSLog(@"*p=%d,**q=%d,***r=%d",*p,**q,***r);
    
    
    int j = 2;
    int *e = &j;
    DynamicArray(e);  //函数调用
    printf("*p = %d\n", *e);
    
    int *d = NULL;
    DynamicArray1(&d);
    printf("*p = %d\n", *d);
    
    
}
void DynamicArray(int *q)
{
    q = malloc(sizeof*q);
    *q = 5;
    return;
}
void DynamicArray1(int **q)
{
    //如果此时传入的实参并没有被初始化的话 那么必须写上上面这句话 因为如果没有这句话的话就表示*q这个变量是没有初始化的是不存在的会报错的
    
    *q = malloc(sizeof*q);
    
    **q = 5;
    
    return;
    
}

-(void)dyadicArray
{
    
    /*
     笔记：
     1.a[0]、a[1]、a[2] 既然是一维数组名，一维数组的数组名表示的就是数组第一个元素的地址，所以 a[0] 表示的就是元素 a[0][0] 的地址，即 a[0]==&a[0][0]；a[1] 表示的就是元素 a[1][0] 的地址，即 a[1]==&a[1][0]；a[2] 表示的就是元素 a[2][0] 的地址，即 a[2]==&a[2][0]。
     2.即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。
     
     疑问：如果我输出*a[3] 并不会报错 但是会输出0？ 这证明在c语言数组中并不会出现数组越界的情况 ？
     
     */
    int a[3][4] = {{1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23}};
    
    int b[3] = {1, 3, 5, 7};
    
    printf("%d--%d--%d\n",*a[5],**a,*b);
    
    /*
     笔记：如果按照下面的方式输入为：140732753012876--140732753012880,140732753012896 此时a[2][3]和a[3]的地址差距为4 为int长度，但是a[4]的地址却比a[3]多16个长度 是4个int的长度和二维数组的第二维度长度吻合
     
     疑问：
     
     */
    
    
    printf("%ld--%ld,%ld\n",&a[2][3],&a[3],&a[4]);
    /*
     笔记：
     
     疑问：
     
     */
    
    printf("%d--%d--%d\n",*(a[0]+2),a[0][2],*(&a[0][1]+1));
    
    /*
     笔记：
     1.二维数组就是一维数组，二维数组 a[3][4] 就是有三个元素 a[0]、a[1]、a[2] 的一维数组，所以数组 a 的第一个元素不是 a[0][0]，而是 a[0]，所以数组名 a 表示的不是元素 a[0][0] 的地址，而是 a[0] 的地址，即：
     a == &a[0]
     而 a[0] 又是 a[0][0] 的地址，即：
     a[0] == &a[0][0]
     所以二维数组名 a 和元素 a[0][0] 的关系是：
     a == &(&a[0][0])
     即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。
     
     2.如第一条所示如果想让p指针指向a这个二维数组的话 那么就必须将*a赋值给p 因为此时a的类型是 int *[3][4] 类型并不是int*类型 并不能直接将a直接赋值给p，因为两者的类型并不一致,那么哪个的类型是int *呢，肯定是a[0][0]， 而a == &a[0] 而a[0] = &[0][0]那么 a=&&a[0][0] &a[0][0]类型为int *类型所以需要把*a的值赋值给p
     3.这种赋值方式虽然不能用p[2][1]这种方式但是 因为在内存中存储的时候并没有什么一位数组二维数组存储方式都是线性存储的所以我们完全可以用*(p+2*4+1)
     疑问：
     
     */
    
    int *p = NULL;
    
    p = *a;
    
    printf("%d--%d--%d\n",*p,*(p+1),*(p+2*4+1));
    
    /*
     笔记：如下方这样定义可以直接将a赋值给q然后写法可以完全按照a的写法来取值
     
     疑问：
     
     */
    
    int (*q)[4] = NULL;
    
    q = a;
    
    printf("%ld--%d\n",a,*q[0]);
    
}

/*
 笔记：
 1.如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。
 2.所以函数指针的定义方式为：函数返回值类型 (* 指针变量名) (函数参数列表);
 3.需要注意的是：“（*指针变量名）”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数。
 4.最后需要注意的是，指向函数的指针变量没有 ++ 和 -- 运算。
 5.int Func(int x);   声明一个函数
   int (*p) (int x);  定义一个函数指针
   p = Func;          将Func函数的首地址赋给指针变量p
 
 
 疑问：
 
 */
-(void)functionPointer
{
    void (*changeFun)(int *,int *);
    changeFun = changeValue;
    int a = 0;
    int b = 1;
    (*changeFun)(&a,&b);
    printf("%d,%d\n",a,b);
    
}
@end
